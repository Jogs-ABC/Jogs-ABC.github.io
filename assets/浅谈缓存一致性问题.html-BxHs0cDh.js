import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,b as o,d as e,a as r,o as i}from"./app-_wb7MljX.js";const l={},n=e("blockquote",null,[e("p",null,"来自 gpt 的摘要： 在引入缓存时，性能和一致性无法同时完全满足，一旦决定使用缓存，短期的不一致性是必须容忍的。为了确保 Redis 和 MySQL 数据的一致性，推荐采用“先更新数据库，再删除缓存”的方案，并结合消息队列或订阅变更日志的方式进一步降低不一致的风险。虽然该方案并非万无一失，但实际发生不一致的概率很低。即便出现短暂的不一致性，也可以通过缓存的失效时间来兜底，从而达到最终一致性。")],-1),p=r('<h2 id="写在前面" tabindex="-1"><a class="header-anchor" href="#写在前面"><span>写在前面</span></a></h2><p>一旦我们决定使用缓存，那必然要面临一致性问题。性能和一致性就像天平的两端，无法做到都满足要求。引入缓存之后，如果为了短时间的不一致性问题，选择让系统设计变得更加复杂的话，完全没必要。</p><h2 id="如何保证-redis-与-mysql-的数据一致性" tabindex="-1"><a class="header-anchor" href="#如何保证-redis-与-mysql-的数据一致性"><span>如何保证 Redis 与 MySQL 的数据一致性？</span></a></h2><p>想要保证数据库和缓存一致性，<strong>推荐采用「先更新数据库，再删除缓存」方案，并配合「消息队列」或「订阅变更日志」的方式来做</strong></p><ul><li>参考：<a href="https://mp.weixin.qq.com/s?__biz=MzIyOTYxNDI5OA==&amp;mid=2247487312&amp;idx=1&amp;sn=fa19566f5729d6598155b5c676eee62d&amp;chksm=e8beb8e5dfc931f3e35655da9da0b61c79f2843101c130cf38996446975014f958a6481aacf1&amp;scene=178&amp;cur_album_id=1699766580538032128#rd" target="_blank" rel="noopener noreferrer">缓存和数据库一致性问题，看这篇就够了 - 水滴与银弹</a></li></ul><h2 id="先写数据库再删缓存一定万无一失吗" tabindex="-1"><a class="header-anchor" href="#先写数据库再删缓存一定万无一失吗"><span>先写数据库再删缓存一定万无一失吗 ？</span></a></h2><p>不是万无一失，「理论」来说是可能发生不一致，但实际真的有可能发生吗？其实概率「很低」，这是因为它必须满足 3 个条件：</p><ol><li><p>缓存刚好已失效</p></li><li><p>读请求 + 写请求并发</p></li><li><p>更新数据库 + 删除缓存的时间，要比读数据库 + 写缓存时间短</p></li></ol><p>仔细想一下，条件 3 发生的概率其实是非常低的。</p><p>因为写数据库一般会先「加锁」，所以写数据库，通常是要比读数据库的时间更长的。</p><p>这么来看，「先更新数据库 + 再删除缓存」的方案，是可以保证数据一致性的。</p><h2 id="延时双删-的第二次删除缓存失败了呢-如何解决" tabindex="-1"><a class="header-anchor" href="#延时双删-的第二次删除缓存失败了呢-如何解决"><span>“延时双删”的第二次删除缓存失败了呢，如何解决？</span></a></h2><p>既然决定使用缓存，就必须容忍「一致性」问题，我们只能尽可能地去降低问题出现的概率。缓存都是有「失效时间」的，就算在这期间存在短期不一致，我们依旧有失效时间来兜底，这样也能达到最终一致。</p>',13);function s(c,d){return i(),a("div",null,[n,o("more"),p])}const g=t(l,[["render",s],["__file","浅谈缓存一致性问题.html.vue"]]),_=JSON.parse(`{"path":"/%E6%96%87%E7%AB%A0/%E6%8A%80%E6%9C%AF/%E6%B5%85%E8%B0%88%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98.html","title":"「浅谈缓存一致性问题」","lang":"zh-CN","frontmatter":{"title":"「浅谈缓存一致性问题」","author":"Jogs","date":"2024-09-23T00:00:00.000Z","category":["技术"],"tag":["Redis"],"editLink":false,"description":"来自 gpt 的摘要： 在引入缓存时，性能和一致性无法同时完全满足，一旦决定使用缓存，短期的不一致性是必须容忍的。为了确保 Redis 和 MySQL 数据的一致性，推荐采用“先更新数据库，再删除缓存”的方案，并结合消息队列或订阅变更日志的方式进一步降低不一致的风险。虽然该方案并非万无一失，但实际发生不一致的概率很低。即便出现短暂的不一致性，也可以通过...","head":[["meta",{"property":"og:url","content":"https://jogs-abc.github.io/%E6%96%87%E7%AB%A0/%E6%8A%80%E6%9C%AF/%E6%B5%85%E8%B0%88%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98.html"}],["meta",{"property":"og:site_name","content":"Jogs' blog"}],["meta",{"property":"og:title","content":"「浅谈缓存一致性问题」"}],["meta",{"property":"og:description","content":"来自 gpt 的摘要： 在引入缓存时，性能和一致性无法同时完全满足，一旦决定使用缓存，短期的不一致性是必须容忍的。为了确保 Redis 和 MySQL 数据的一致性，推荐采用“先更新数据库，再删除缓存”的方案，并结合消息队列或订阅变更日志的方式进一步降低不一致的风险。虽然该方案并非万无一失，但实际发生不一致的概率很低。即便出现短暂的不一致性，也可以通过..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Jogs"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:published_time","content":"2024-09-23T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"「浅谈缓存一致性问题」\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-09-23T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Jogs\\"}]}"]]},"headers":[{"level":2,"title":"写在前面","slug":"写在前面","link":"#写在前面","children":[]},{"level":2,"title":"如何保证 Redis 与 MySQL 的数据一致性？","slug":"如何保证-redis-与-mysql-的数据一致性","link":"#如何保证-redis-与-mysql-的数据一致性","children":[]},{"level":2,"title":"先写数据库再删缓存一定万无一失吗 ？","slug":"先写数据库再删缓存一定万无一失吗","link":"#先写数据库再删缓存一定万无一失吗","children":[]},{"level":2,"title":"“延时双删”的第二次删除缓存失败了呢，如何解决？","slug":"延时双删-的第二次删除缓存失败了呢-如何解决","link":"#延时双删-的第二次删除缓存失败了呢-如何解决","children":[]}],"git":{},"readingTime":{"minutes":2.23,"words":668},"filePathRelative":"文章/技术/浅谈缓存一致性问题.md","localizedDate":"2024年9月23日","excerpt":"<blockquote>\\n<p>来自 gpt 的摘要：\\n在引入缓存时，性能和一致性无法同时完全满足，一旦决定使用缓存，短期的不一致性是必须容忍的。为了确保 Redis 和 MySQL 数据的一致性，推荐采用“先更新数据库，再删除缓存”的方案，并结合消息队列或订阅变更日志的方式进一步降低不一致的风险。虽然该方案并非万无一失，但实际发生不一致的概率很低。即便出现短暂的不一致性，也可以通过缓存的失效时间来兜底，从而达到最终一致性。</p>\\n</blockquote>\\n<!--more-->\\n<h2>写在前面</h2>\\n<p>一旦我们决定使用缓存，那必然要面临一致性问题。性能和一致性就像天平的两端，无法做到都满足要求。引入缓存之后，如果为了短时间的不一致性问题，选择让系统设计变得更加复杂的话，完全没必要。</p>","autoDesc":true}`);export{g as comp,_ as data};
