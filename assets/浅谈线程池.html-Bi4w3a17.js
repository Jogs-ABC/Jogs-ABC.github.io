import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,b as a,d as e,a as t,o}from"./app-ddVZ3q__.js";const r="/assets/images/%E6%B5%85%E8%B0%88%E7%BA%BF%E7%A8%8B%E6%B1%A0.png",n={},c=e("blockquote",null,[e("p",null,"来自 gpt 的摘要： 线程池是管理线程的资源池，主要作用在于通过重复利用已创建的线程降低资源消耗、提高响应速度、以及管理线程的使用和分配。常见的线程池参数包括核心线程数、最大线程数、任务队列、线程存活时间等。线程池在任务执行时，首先创建核心线程处理任务，当任务量超过核心线程数时，进入阻塞队列，队列满时会根据最大线程数创建新线程，超出后根据预设的拒绝策略处理多余任务。线程池的选择可以通过 ThreadPoolExecutor 或 Executors 工具类创建，常用的线程池类型包括 SingleThreadExecutor、FixedThreadPool、CachedThreadPool 和 ScheduledThreadPool。根据任务的特性，线程池的线程数可以根据 CPU 密集型任务和 I/O 密集型任务来规划，CPU 密集型任务推荐使用等于 CPU 核心数的线程，I/O 密集型任务建议使用多倍于核心数的线程数。引入线程池能有效提高系统的性能，尤其适合 I/O 密集型任务，通过并发执行减少等待时间，从而提升整体计算效率。")],-1),h=t('<h2 id="讲讲线程池" tabindex="-1"><a class="header-anchor" href="#讲讲线程池"><span>讲讲线程池</span></a></h2><h3 id="线程池简介" tabindex="-1"><a class="header-anchor" href="#线程池简介"><span>线程池简介</span></a></h3><p>通俗来讲，线程池就是管理一系列线程的资源池，其提供了一种限制和管理线程资源的方式。每个线程池还维护一些基本统计信息，例如已完成任务的数量。</p><h3 id="线程池的好处" tabindex="-1"><a class="header-anchor" href="#线程池的好处"><span>线程池的好处</span></a></h3><ul><li>降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度：当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li>提高线程的可管理性：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h3 id="线程池的参数" tabindex="-1"><a class="header-anchor" href="#线程池的参数"><span>线程池的参数</span></a></h3><p>ThreadPoolExecutor 3 个最重要的参数：</p><ul><li>corePoolSize：任务队列未达到队列容量时，最大可以同时运行的线程数量。</li><li>maximumPoolSize ：任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li>workQueue：新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。 ThreadPoolExecutor 其他常见参数 :</li><li>keepAliveTime：线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime 才会被回收销毁。</li><li>unit：keepAliveTime 参数的时间单位。</li><li>threadFactory：executor 创建新线程的时候会用到。</li><li>handler：拒绝策略（后面会单独详细介绍一下）。</li></ul><h3 id="线程池的拒绝策略" tabindex="-1"><a class="header-anchor" href="#线程池的拒绝策略"><span>线程池的拒绝策略</span></a></h3><p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，ThreadPoolExecutor 定义一些策略:</p><ul><li>ThreadPoolExecutor.AbortPolicy：抛出 RejectedExecutionException来拒绝新任务的处理。</li><li>ThreadPoolExecutor.CallerRunsPolicy：调用执行自己的线程运行任务，也就是直接在调用 execute 方法的线程中运行( run )被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li><li>ThreadPoolExecutor.DiscardPolicy：不处理新任务，直接丢弃掉。</li><li>ThreadPoolExecutor.DiscardOldestPolicy：此策略将丢弃最早的未处理的任务请求。</li></ul><h3 id="如何用线程池" tabindex="-1"><a class="header-anchor" href="#如何用线程池"><span>如何用线程池</span></a></h3><ul><li>方式一：通过 ThreadPoolExecutor 构造函数来创建（推荐）。</li><li>方式二：通过 Executor 框架的工具类 Executors 来创建。</li></ul><h3 id="常用的线程池" tabindex="-1"><a class="header-anchor" href="#常用的线程池"><span>常用的线程池</span></a></h3><ul><li>SingleThreadExecutor：创建一个单线程的线程池，此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</li><li>FixedThreadPool：创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。</li><li>CachedThreadPool：创建一个可缓存的线程池，此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小。</li><li>ScheduledThreadPool：创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求。</li><li>SingleThreadExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。</li></ul><h2 id="线程池的执行流程" tabindex="-1"><a class="header-anchor" href="#线程池的执行流程"><span>线程池的执行流程</span></a></h2><p>当提交一个新任务到线程池时，具体的执行流程如下：</p><ol><li>当我们提交任务，线程池会根据 corePoolSize 大小创建若干任务数量线程执行任务</li><li>当任务的数量超过 corePoolSize 数量，后续的任务将会进入阻塞队列阻塞排队</li><li>当阻塞队列也满了之后，那么将会继续创建（maximumPoolSize - corePoolSize）个数量的线程来执行任务，如果任务处理完成，maximumPoolSize - corePoolSize 额外创建的线程等待 keepAliveTime 之后被自动销毁</li><li>如果达到 maximumPoolSize，阻塞队列还是满的状态，那么将根据不同的拒绝策略对应处理 <img src="'+r+'" alt="浅谈线程池" loading="lazy"></li></ol><h2 id="线程池的核心线程数和最大线程数如何规划" tabindex="-1"><a class="header-anchor" href="#线程池的核心线程数和最大线程数如何规划"><span>线程池的核心线程数和最大线程数如何规划</span></a></h2><h3 id="有一个简单并且适用面比较广的公式" tabindex="-1"><a class="header-anchor" href="#有一个简单并且适用面比较广的公式"><span>有一个简单并且适用面比较广的公式 ：</span></a></h3><ul><li>CPU 密集型任务 (N)： 这种任务消耗的主要是 CPU 资源，线程数应设置为 N（CPU 核心数）。由于任务主要瓶颈在于 CPU 计算能力，与核心数相等的线程数能够最大化 CPU 利用率，过多线程反而会导致竞争和上下文切换开销。</li><li>I/O 密集型任务(M * N)：这类任务大部分时间处理 I/O 交互，线程在等待 I/O 时不占用 CPU。 为了充分利用 CPU 资源，线程数可以设置为 M * N，其中 N 是 CPU 核心数，M 是一个大于 1 的倍数，建议默认设置为 2 ，具体取值取决于 I/O 等待时间和任务特点，需要通过测试和监控找到最佳平衡点。</li></ul><h3 id="cpu-密集型任务不再推荐-n-1-原因如下" tabindex="-1"><a class="header-anchor" href="#cpu-密集型任务不再推荐-n-1-原因如下"><span>CPU 密集型任务不再推荐 N+1，原因如下：</span></a></h3><ul><li>&quot;N+1&quot; 的初衷是希望预留线程处理突发暂停，但实际上，处理缺页中断等情况仍然需要占用 CPU 核心。</li><li>CPU 密集场景下，CPU 始终是瓶颈，预留线程并不能凭空增加 CPU 处理能力，反而可能加剧竞争。</li></ul><h3 id="如何判断是-cpu-密集任务还是-io-密集任务" tabindex="-1"><a class="header-anchor" href="#如何判断是-cpu-密集任务还是-io-密集任务"><span>如何判断是 CPU 密集任务还是 IO 密集任务？</span></a></h3><p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。但凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p><h2 id="为何在项目中引入线程池" tabindex="-1"><a class="header-anchor" href="#为何在项目中引入线程池"><span>为何在项目中引入线程池？</span></a></h2><p>参考：由于这个项目它主要的性能瓶颈是在于网络 IO，调用的接口平时时长为 100 ms，高负载的时候高达数秒，实际获取数据的时间是大于我们数据实际计算的时间，可见这个项目是一个 IO 密集型的项目，所以我们引入线程池来进行异步计算，通过提高并发数量来尽量抵消花费在 IO 等待上的计算空闲，保证计算的高性能。</p>',27);function s(d,p){return o(),i("div",null,[c,a("more"),h])}const g=l(n,[["render",s],["__file","浅谈线程池.html.vue"]]),m=JSON.parse(`{"path":"/%E6%96%87%E7%AB%A0/%E6%8A%80%E6%9C%AF/%E6%B5%85%E8%B0%88%E7%BA%BF%E7%A8%8B%E6%B1%A0.html","title":"「浅谈线程池」","lang":"zh-CN","frontmatter":{"title":"「浅谈线程池」","author":"Jogs","date":"2024-09-26T00:00:00.000Z","category":["技术"],"tag":["并发"],"editLink":false,"description":"来自 gpt 的摘要： 线程池是管理线程的资源池，主要作用在于通过重复利用已创建的线程降低资源消耗、提高响应速度、以及管理线程的使用和分配。常见的线程池参数包括核心线程数、最大线程数、任务队列、线程存活时间等。线程池在任务执行时，首先创建核心线程处理任务，当任务量超过核心线程数时，进入阻塞队列，队列满时会根据最大线程数创建新线程，超出后根据预设的拒绝策...","head":[["meta",{"property":"og:url","content":"https://jogs-abc.github.io/%E6%96%87%E7%AB%A0/%E6%8A%80%E6%9C%AF/%E6%B5%85%E8%B0%88%E7%BA%BF%E7%A8%8B%E6%B1%A0.html"}],["meta",{"property":"og:site_name","content":"Jogs's blog"}],["meta",{"property":"og:title","content":"「浅谈线程池」"}],["meta",{"property":"og:description","content":"来自 gpt 的摘要： 线程池是管理线程的资源池，主要作用在于通过重复利用已创建的线程降低资源消耗、提高响应速度、以及管理线程的使用和分配。常见的线程池参数包括核心线程数、最大线程数、任务队列、线程存活时间等。线程池在任务执行时，首先创建核心线程处理任务，当任务量超过核心线程数时，进入阻塞队列，队列满时会根据最大线程数创建新线程，超出后根据预设的拒绝策..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://jogs-abc.github.io/assets/images/浅谈线程池.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Jogs"}],["meta",{"property":"article:tag","content":"并发"}],["meta",{"property":"article:published_time","content":"2024-09-26T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"「浅谈线程池」\\",\\"image\\":[\\"https://jogs-abc.github.io/assets/images/浅谈线程池.png\\"],\\"datePublished\\":\\"2024-09-26T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Jogs\\"}]}"]]},"headers":[{"level":2,"title":"讲讲线程池","slug":"讲讲线程池","link":"#讲讲线程池","children":[{"level":3,"title":"线程池简介","slug":"线程池简介","link":"#线程池简介","children":[]},{"level":3,"title":"线程池的好处","slug":"线程池的好处","link":"#线程池的好处","children":[]},{"level":3,"title":"线程池的参数","slug":"线程池的参数","link":"#线程池的参数","children":[]},{"level":3,"title":"线程池的拒绝策略","slug":"线程池的拒绝策略","link":"#线程池的拒绝策略","children":[]},{"level":3,"title":"如何用线程池","slug":"如何用线程池","link":"#如何用线程池","children":[]},{"level":3,"title":"常用的线程池","slug":"常用的线程池","link":"#常用的线程池","children":[]}]},{"level":2,"title":"线程池的执行流程","slug":"线程池的执行流程","link":"#线程池的执行流程","children":[]},{"level":2,"title":"线程池的核心线程数和最大线程数如何规划","slug":"线程池的核心线程数和最大线程数如何规划","link":"#线程池的核心线程数和最大线程数如何规划","children":[{"level":3,"title":"有一个简单并且适用面比较广的公式 ：","slug":"有一个简单并且适用面比较广的公式","link":"#有一个简单并且适用面比较广的公式","children":[]},{"level":3,"title":"CPU 密集型任务不再推荐 N+1，原因如下：","slug":"cpu-密集型任务不再推荐-n-1-原因如下","link":"#cpu-密集型任务不再推荐-n-1-原因如下","children":[]},{"level":3,"title":"如何判断是 CPU 密集任务还是 IO 密集任务？","slug":"如何判断是-cpu-密集任务还是-io-密集任务","link":"#如何判断是-cpu-密集任务还是-io-密集任务","children":[]}]},{"level":2,"title":"为何在项目中引入线程池？","slug":"为何在项目中引入线程池","link":"#为何在项目中引入线程池","children":[]}],"git":{},"readingTime":{"minutes":6.75,"words":2025},"filePathRelative":"文章/技术/浅谈线程池.md","localizedDate":"2024年9月26日","excerpt":"<blockquote>\\n<p>来自 gpt 的摘要：\\n线程池是管理线程的资源池，主要作用在于通过重复利用已创建的线程降低资源消耗、提高响应速度、以及管理线程的使用和分配。常见的线程池参数包括核心线程数、最大线程数、任务队列、线程存活时间等。线程池在任务执行时，首先创建核心线程处理任务，当任务量超过核心线程数时，进入阻塞队列，队列满时会根据最大线程数创建新线程，超出后根据预设的拒绝策略处理多余任务。线程池的选择可以通过 ThreadPoolExecutor 或 Executors 工具类创建，常用的线程池类型包括 SingleThreadExecutor、FixedThreadPool、CachedThreadPool 和 ScheduledThreadPool。根据任务的特性，线程池的线程数可以根据 CPU 密集型任务和 I/O 密集型任务来规划，CPU 密集型任务推荐使用等于 CPU 核心数的线程，I/O 密集型任务建议使用多倍于核心数的线程数。引入线程池能有效提高系统的性能，尤其适合 I/O 密集型任务，通过并发执行减少等待时间，从而提升整体计算效率。</p>\\n</blockquote>","autoDesc":true}`);export{g as comp,m as data};
