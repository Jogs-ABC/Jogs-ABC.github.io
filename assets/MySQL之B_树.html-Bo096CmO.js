import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as l,b as o,d as e,a,o as n}from"./app-_wb7MljX.js";const p={},i=e("blockquote",null,[e("p",null,"来自 gpt 的摘要： MySQL 提供了四种隔离级别，用于控制并发事务之间的数据可见性：READ-UNCOMMITTED 允许读取未提交的变更，可能导致脏读、不可重复读和幻读；READ-COMMITTED 仅能读取已提交的数据，避免脏读，但仍无法避免不可重复读和幻读；REPEATABLE-READ 确保同一事务中的多次读取结果一致，防止脏读和不可重复读，但幻读仍可能发生；SERIALIZABLE 是最高级别的隔离，所有事务串行执行，完全避免脏读、不可重复读和幻读，但性能较低。MySQL 默认采用 REPEATABLE-READ，在大多数情况下可以避免幻读，无需使用性能开销更大的串行化隔离级别。 这些隔离级别的实现依赖于 锁机制 和 MVCC（多版本并发控制）。高隔离级别如 SERIALIZABLE 主要依靠锁来控制并发，而 READ-COMMITTED 和 REPEATABLE-READ 通过 MVCC 实现。此外，REPEATABLE-READ 在当前读情况下需要使用锁来避免幻读。 MySQL 的事务确保数据库操作构成一个逻辑整体，符合 ACID 特性：原子性 保证事务内的操作不可分割；一致性 确保数据在事务前后保持一致；隔离性 使并发事务互不干扰；持久性 确保已提交的事务在故障后仍然有效。InnoDB 存储引擎通过 redo log 实现持久性，undo log 确保原子性，MVCC 和锁机制 实现隔离性，而一致性依赖其他三者的共同保障。")],-1),E=a('<h2 id="b-树的介绍" tabindex="-1"><a class="header-anchor" href="#b-树的介绍"><span>B+树的介绍</span></a></h2><p>B+树是一种多路搜索树，其定义基本与 B-树相同，但在某些方面进行了优化。B+树的主要特点包括：</p><ol><li><p>所有的叶子结点中包含了全部关键字的信息，以及指向包含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</p></li><li><p>所有的非终端结点可以看成索引部分，结点中仅含有其子树（根结点）中最大（或最小）关键字。</p></li><li><p>非叶子节点的关键字数目等于它的分支数量。</p></li></ol><p>在B+树中，数据存放的更加紧密，具有更好的空间局部性，因此访问叶子节点上关联的数据具有更好的缓存命中率。同时，由于叶子结点都是相链的，对整棵树的遍历只需要一次线性遍历叶子结点即可，且由于数据顺序排列并且相连，所以便于区间查找和搜索。</p><h2 id="b-树的底层" tabindex="-1"><a class="header-anchor" href="#b-树的底层"><span>B+树的底层</span></a></h2><p>B+树的底层实现主要是基于多路平衡查找树。在查询过程中，从根节点出发，查找到叶子节点方可获得所查键值，然后根据查询判断是否需要回表查询数据。这种结构使得B+树在访问数据时具有更高的效率。</p><h2 id="mysql-为什么用-b-树" tabindex="-1"><a class="header-anchor" href="#mysql-为什么用-b-树"><span>MySQL 为什么用 B+树？</span></a></h2><p>B+树在数据库和许多其他数据结构中得到广泛应用的原因主要有以下几点：</p><ol><li><p>I/O次数更少：由于 B+树的层数比其他树（如二叉搜索树）小，因此读取节点并进行 I/O 操作的次数也会减少。同时，B+树中间节点不存储数据，只存储索引，使得相同大小的磁盘页可以容纳更多的节点元素，进一步减少了 I/O 次数。</p></li><li><p>查询更加稳定：B+树每次查询都必须访问到叶子节点，而 B-树可能在中间节点或叶子节点找到匹配元素，因此 B+树的查询性能更为稳定。</p></li><li><p>更利于查询范围：由于 B+树的叶子节点首尾相连，因此在进行范围查询时，只需要在链表上进行遍历，效率非常高。</p></li></ol><h2 id="b-树和-b-树的区别" tabindex="-1"><a class="header-anchor" href="#b-树和-b-树的区别"><span>B+树和 B 树的区别？</span></a></h2><p>B+树与 B 树差异的点，主要是以下这几点：</p><ul><li><p>叶子节点（最底部的节点）才会存放实际数据（索引+记录），非叶子节点只会存放索引；</p></li><li><p>所有索引都会在叶子节点出现，叶子节点之间构成一个有序链表；</p></li><li><p>非叶子节点的索引也会同时存在在子节点中，并且是在子节点中所有索引的最大（或最小）。</p></li><li><p>非叶子节点中有多少个子节点，就有多少个索引；</p></li></ul>',12);function r(s,c){return n(),l("div",null,[i,o("more"),E])}const d=t(p,[["render",r],["__file","MySQL之B_树.html.vue"]]),M=JSON.parse(`{"path":"/%E6%96%87%E7%AB%A0/%E6%8A%80%E6%9C%AF/MySQL%E4%B9%8BB_%E6%A0%91.html","title":"「MySQL之B+树」","lang":"zh-CN","frontmatter":{"title":"「MySQL之B+树」","author":"Jogs","date":"2024-10-12T00:00:00.000Z","category":["技术"],"tag":["MySQL"],"editLink":false,"description":"来自 gpt 的摘要： MySQL 提供了四种隔离级别，用于控制并发事务之间的数据可见性：READ-UNCOMMITTED 允许读取未提交的变更，可能导致脏读、不可重复读和幻读；READ-COMMITTED 仅能读取已提交的数据，避免脏读，但仍无法避免不可重复读和幻读；REPEATABLE-READ 确保同一事务中的多次读取结果一致，防止脏读和不可重复...","head":[["meta",{"property":"og:url","content":"https://jogs-abc.github.io/%E6%96%87%E7%AB%A0/%E6%8A%80%E6%9C%AF/MySQL%E4%B9%8BB_%E6%A0%91.html"}],["meta",{"property":"og:site_name","content":"Jogs' blog"}],["meta",{"property":"og:title","content":"「MySQL之B+树」"}],["meta",{"property":"og:description","content":"来自 gpt 的摘要： MySQL 提供了四种隔离级别，用于控制并发事务之间的数据可见性：READ-UNCOMMITTED 允许读取未提交的变更，可能导致脏读、不可重复读和幻读；READ-COMMITTED 仅能读取已提交的数据，避免脏读，但仍无法避免不可重复读和幻读；REPEATABLE-READ 确保同一事务中的多次读取结果一致，防止脏读和不可重复..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Jogs"}],["meta",{"property":"article:tag","content":"MySQL"}],["meta",{"property":"article:published_time","content":"2024-10-12T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"「MySQL之B+树」\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-10-12T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Jogs\\"}]}"]]},"headers":[{"level":2,"title":"B+树的介绍","slug":"b-树的介绍","link":"#b-树的介绍","children":[]},{"level":2,"title":"B+树的底层","slug":"b-树的底层","link":"#b-树的底层","children":[]},{"level":2,"title":"MySQL 为什么用 B+树？","slug":"mysql-为什么用-b-树","link":"#mysql-为什么用-b-树","children":[]},{"level":2,"title":"B+树和 B 树的区别？","slug":"b-树和-b-树的区别","link":"#b-树和-b-树的区别","children":[]}],"git":{},"readingTime":{"minutes":3.85,"words":1155},"filePathRelative":"文章/技术/MySQL之B+树.md","localizedDate":"2024年10月12日","excerpt":"<blockquote>\\n<p>来自 gpt 的摘要：\\nMySQL 提供了四种隔离级别，用于控制并发事务之间的数据可见性：READ-UNCOMMITTED 允许读取未提交的变更，可能导致脏读、不可重复读和幻读；READ-COMMITTED 仅能读取已提交的数据，避免脏读，但仍无法避免不可重复读和幻读；REPEATABLE-READ 确保同一事务中的多次读取结果一致，防止脏读和不可重复读，但幻读仍可能发生；SERIALIZABLE 是最高级别的隔离，所有事务串行执行，完全避免脏读、不可重复读和幻读，但性能较低。MySQL 默认采用 REPEATABLE-READ，在大多数情况下可以避免幻读，无需使用性能开销更大的串行化隔离级别。\\n这些隔离级别的实现依赖于 锁机制 和 MVCC（多版本并发控制）。高隔离级别如 SERIALIZABLE 主要依靠锁来控制并发，而 READ-COMMITTED 和 REPEATABLE-READ 通过 MVCC 实现。此外，REPEATABLE-READ 在当前读情况下需要使用锁来避免幻读。\\nMySQL 的事务确保数据库操作构成一个逻辑整体，符合 ACID 特性：原子性 保证事务内的操作不可分割；一致性 确保数据在事务前后保持一致；隔离性 使并发事务互不干扰；持久性 确保已提交的事务在故障后仍然有效。InnoDB 存储引擎通过 redo log 实现持久性，undo log 确保原子性，MVCC 和锁机制 实现隔离性，而一致性依赖其他三者的共同保障。</p>\\n</blockquote>","autoDesc":true}`);export{d as comp,M as data};
