import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,b as l,d as e,a as n,o as E}from"./app-C_IVUJ4N.js";const a={},i=e("blockquote",null,[e("p",null,"来自 gpt 的摘要： MySQL 提供了四种隔离级别，用于控制并发事务之间的数据可见性：READ-UNCOMMITTED 允许读取未提交的变更，可能导致脏读、不可重复读和幻读；READ-COMMITTED 仅能读取已提交的数据，避免脏读，但仍无法避免不可重复读和幻读；REPEATABLE-READ 确保同一事务中的多次读取结果一致，防止脏读和不可重复读，但幻读仍可能发生；SERIALIZABLE 是最高级别的隔离，所有事务串行执行，完全避免脏读、不可重复读和幻读，但性能较低。MySQL 默认采用 REPEATABLE-READ，在大多数情况下可以避免幻读，无需使用性能开销更大的串行化隔离级别。 这些隔离级别的实现依赖于 锁机制 和 MVCC（多版本并发控制）。高隔离级别如 SERIALIZABLE 主要依靠锁来控制并发，而 READ-COMMITTED 和 REPEATABLE-READ 通过 MVCC 实现。此外，REPEATABLE-READ 在当前读情况下需要使用锁来避免幻读。 MySQL 的事务确保数据库操作构成一个逻辑整体，符合 ACID 特性：原子性 保证事务内的操作不可分割；一致性 确保数据在事务前后保持一致；隔离性 使并发事务互不干扰；持久性 确保已提交的事务在故障后仍然有效。InnoDB 存储引擎通过 redo log 实现持久性，undo log 确保原子性，MVCC 和锁机制 实现隔离性，而一致性依赖其他三者的共同保障。")],-1),r=n('<h2 id="mysql-隔离机制有哪些" tabindex="-1"><a class="header-anchor" href="#mysql-隔离机制有哪些"><span>Mysql 隔离机制有哪些 ？</span></a></h2><ul><li><strong>READ UNCOMMITTED（读未提交）</strong></li></ul><p>这是最低的隔离级别。在这个级别下，一个事务可以读取另一个未提交事务的修改。这可能导致脏读、不可重复读和幻读。</p><p>实现：无需额外的机制，直接读取数据即可。</p><ul><li><strong>READ COMMITTED（读已提交）</strong></li></ul><p>大多数数据库系统的默认隔离级别（但不是 MySQL 的默认级别）。它只能读取已经提交的数据。这可以防止脏读，但仍然可能导致不可重复读和幻读。</p><p>实现：当事务进行时，它读取的数据行会被加上锁，其他事务不能修改这些数据行，直到当前事务提交或回滚。</p><ul><li><strong>REPEATABLE READ（可重复读）</strong></li></ul><p>MySQL 的默认隔离级别。它确保了在同一个事务中多次读取同样记录的结果是一致的。这可以防止脏读和不可重复读，但仍然可能导致幻读。</p><p>实现：MySQL 使用多版本并发控制（MVCC）来实现这个隔离级别。每个事务都看到一个一致的数据快照，即使其他事务正在修改数据。</p><ul><li><strong>SERIALIZABLE（可串行化）</strong></li></ul><p>这是最高的隔离级别。它通过强制事务串行执行，从而避免脏读、不可重复读和幻读。但是，这可能会大大降低并发性能。</p><p>实现：在 SERIALIZABLE 级别下，每个读写事务都会获得一个唯一的锁，这确保了事务的串行执行。MySQL 通过表锁或行锁来实现这一点，具体取决于存储引擎。</p><p>MySQL 在「可重复读」隔离级别下，可以很大程度上避免幻读现象的发生（注意是很大程度避免，并不是彻底避免），所以 MySQL 并不会使用「串行化」隔离级别来避免幻读现象的发生，因为使用「串行化」隔离级别会影响性能。</p><h2 id="mysql-隔离机制怎么实现的" tabindex="-1"><a class="header-anchor" href="#mysql-隔离机制怎么实现的"><span>Mysql 隔离机制怎么实现的 ？</span></a></h2><p>MySQL 的隔离级别基于锁和 MVCC 机制共同实现的。</p><p>SERIALIZABLE 隔离级别是通过锁来实现的，READ-COMMITTED 和 REPEATABLE-READ 隔离级别是基于 MVCC 实现的。不过， SERIALIZABLE 之外的其他隔离级别可能也需要用到锁机制，就比如 REPEATABLE-READ 在当前读情况下需要使用加锁读来保证不会出现幻读。</p><h2 id="数据库事务了解吗" tabindex="-1"><a class="header-anchor" href="#数据库事务了解吗"><span>数据库事务了解吗 ？</span></a></h2><p>数据库事务可以保证多个对数据库的操作（也就是 SQL 语句）构成一个逻辑上的整体。构成这个逻辑上的整体的这些数据库操作遵循：<strong>要么全部执行成功,要么全部不执行</strong> 。</p><h2 id="数据库事务的特性" tabindex="-1"><a class="header-anchor" href="#数据库事务的特性"><span>数据库事务的特性 ？</span></a></h2><p><strong>ACID</strong> 特性：</p><ul><li><p><strong>原子性</strong>（<code>Atomicity</code>）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</p></li><li><p><strong>一致性</strong>（<code>Consistency</code>）：执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</p></li><li><p><strong>隔离性</strong>（<code>Isolation</code>）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</p></li><li><p><strong>持久性</strong>（<code>Durability</code>）：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</p></li></ul><p>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！</p><h2 id="innodb-引擎通过什么技术来保证事务的这四个特性" tabindex="-1"><a class="header-anchor" href="#innodb-引擎通过什么技术来保证事务的这四个特性"><span>InnoDB 引擎通过什么技术来保证事务的这四个特性？</span></a></h2><ul><li><p>持久性是通过 redo log （重做日志）来保证的；</p></li><li><p>原子性是通过 undo log（回滚日志） 来保证的；</p></li><li><p>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；</p></li><li><p>一致性则是通过持久性+原子性+隔离性来保证；</p></li></ul>',25);function p(s,A){return E(),o("div",null,[i,l("more"),r])}const d=t(a,[["render",p],["__file","浅谈MySQL事务.html.vue"]]),L=JSON.parse(`{"path":"/%E6%96%87%E7%AB%A0/%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/%E6%B5%85%E8%B0%88MySQL%E4%BA%8B%E5%8A%A1.html","title":"「浅谈MySQL事务」","lang":"zh-CN","frontmatter":{"title":"「浅谈MySQL事务」","author":"Jogs","date":"2024-10-12T00:00:00.000Z","category":["技术"],"tag":["MySQL"],"editLink":false,"description":"来自 gpt 的摘要： MySQL 提供了四种隔离级别，用于控制并发事务之间的数据可见性：READ-UNCOMMITTED 允许读取未提交的变更，可能导致脏读、不可重复读和幻读；READ-COMMITTED 仅能读取已提交的数据，避免脏读，但仍无法避免不可重复读和幻读；REPEATABLE-READ 确保同一事务中的多次读取结果一致，防止脏读和不可重复...","head":[["meta",{"property":"og:url","content":"https://jogs-abc.github.io/%E6%96%87%E7%AB%A0/%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/%E6%B5%85%E8%B0%88MySQL%E4%BA%8B%E5%8A%A1.html"}],["meta",{"property":"og:site_name","content":"Jogs' blog"}],["meta",{"property":"og:title","content":"「浅谈MySQL事务」"}],["meta",{"property":"og:description","content":"来自 gpt 的摘要： MySQL 提供了四种隔离级别，用于控制并发事务之间的数据可见性：READ-UNCOMMITTED 允许读取未提交的变更，可能导致脏读、不可重复读和幻读；READ-COMMITTED 仅能读取已提交的数据，避免脏读，但仍无法避免不可重复读和幻读；REPEATABLE-READ 确保同一事务中的多次读取结果一致，防止脏读和不可重复..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Jogs"}],["meta",{"property":"article:tag","content":"MySQL"}],["meta",{"property":"article:published_time","content":"2024-10-12T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"「浅谈MySQL事务」\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-10-12T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Jogs\\"}]}"]]},"headers":[{"level":2,"title":"Mysql 隔离机制有哪些 ？","slug":"mysql-隔离机制有哪些","link":"#mysql-隔离机制有哪些","children":[]},{"level":2,"title":"Mysql 隔离机制怎么实现的 ？","slug":"mysql-隔离机制怎么实现的","link":"#mysql-隔离机制怎么实现的","children":[]},{"level":2,"title":"数据库事务了解吗 ？","slug":"数据库事务了解吗","link":"#数据库事务了解吗","children":[]},{"level":2,"title":"数据库事务的特性 ？","slug":"数据库事务的特性","link":"#数据库事务的特性","children":[]},{"level":2,"title":"InnoDB 引擎通过什么技术来保证事务的这四个特性？","slug":"innodb-引擎通过什么技术来保证事务的这四个特性","link":"#innodb-引擎通过什么技术来保证事务的这四个特性","children":[]}],"git":{},"readingTime":{"minutes":4.76,"words":1427},"filePathRelative":"文章/技术整理/浅谈MySQL事务.md","localizedDate":"2024年10月12日","excerpt":"<blockquote>\\n<p>来自 gpt 的摘要：\\nMySQL 提供了四种隔离级别，用于控制并发事务之间的数据可见性：READ-UNCOMMITTED 允许读取未提交的变更，可能导致脏读、不可重复读和幻读；READ-COMMITTED 仅能读取已提交的数据，避免脏读，但仍无法避免不可重复读和幻读；REPEATABLE-READ 确保同一事务中的多次读取结果一致，防止脏读和不可重复读，但幻读仍可能发生；SERIALIZABLE 是最高级别的隔离，所有事务串行执行，完全避免脏读、不可重复读和幻读，但性能较低。MySQL 默认采用 REPEATABLE-READ，在大多数情况下可以避免幻读，无需使用性能开销更大的串行化隔离级别。\\n这些隔离级别的实现依赖于 锁机制 和 MVCC（多版本并发控制）。高隔离级别如 SERIALIZABLE 主要依靠锁来控制并发，而 READ-COMMITTED 和 REPEATABLE-READ 通过 MVCC 实现。此外，REPEATABLE-READ 在当前读情况下需要使用锁来避免幻读。\\nMySQL 的事务确保数据库操作构成一个逻辑整体，符合 ACID 特性：原子性 保证事务内的操作不可分割；一致性 确保数据在事务前后保持一致；隔离性 使并发事务互不干扰；持久性 确保已提交的事务在故障后仍然有效。InnoDB 存储引擎通过 redo log 实现持久性，undo log 确保原子性，MVCC 和锁机制 实现隔离性，而一致性依赖其他三者的共同保障。</p>\\n</blockquote>","autoDesc":true}`);export{d as comp,L as data};
