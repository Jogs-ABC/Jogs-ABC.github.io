import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,b as h,d as a,a as p,o}from"./app-C_IVUJ4N.js";const t={},n=a("blockquote",null,[a("p",null,"来自 gpt 的摘要： HashMap 是一种基于数组和链表（或红黑树）的数据结构，用于存储键值对。在插入元素时，通过键的 hashCode() 方法计算哈希值，并经过扰动函数确定元素在数组中的位置。Java 8 之前，HashMap 通过链表解决哈希碰撞问题，而在 Java 8 之后，当链表长度超过 8 时，链表会转换为红黑树，以提升效率。当 HashMap 的元素数量达到其容量的 75% 时，触发扩容，容量通常增加为原来的两倍。 HashMap 和 HashSet 的主要区别在于前者存储键值对，而后者仅存储对象。HashSet 的底层依赖于 HashMap，通过 HashMap 的键来存储对象。相比之下，HashMap 是非线程安全的，而 Hashtable 是线程安全的，但性能较低。此外，HashMap 允许 null 键和值，而 Hashtable 不允许。 HashMap 在多线程环境下可能不安全，尤其在插入和扩容操作时，可能导致数据不一致或死循环。要解决这个问题，可以使用 ConcurrentHashMap，它通过细粒度锁和 CAS（Compare-And-Swap）机制保证并发环境下的安全性。")],-1),l=p('<h3 id="hashmap-底层原理" tabindex="-1"><a class="header-anchor" href="#hashmap-底层原理"><span>HashMap 底层原理？</span></a></h3><p><code>HashMap</code> 底层是数组和链表（Java 8 之前）或红黑树（Java 8 之后）的结合体。插入时通过 <code>hashCode()</code> 计算哈希值，经过扰动函数处理后确定存放位置。如果发生哈希碰撞，Java 8 之前通过链表解决，Java 8 之后当链表长度超过 8 时且数组容量超过 64 时转换为红黑树以提高效率。此外，<code>HashMap</code> 的默认负载因子是 0.75，当元素数量达到容量的 75% 时会触发扩容操作。</p><h3 id="hashmap-和-hashset-的区别" tabindex="-1"><a class="header-anchor" href="#hashmap-和-hashset-的区别"><span>HashMap 和 HashSet 的区别？</span></a></h3><ul><li><p><code>HashMap</code> 存储键值对，<code>HashSet</code> 仅存储对象。</p></li><li><p><code>HashSet</code> 底层基于 <code>HashMap</code>，插入元素时，<code>HashSet</code> 使用 <code>HashMap</code> 的键来存储对象。</p></li></ul><h3 id="hashmap-和-hashtable-的区别" tabindex="-1"><a class="header-anchor" href="#hashmap-和-hashtable-的区别"><span>HashMap 和 Hashtable 的区别？</span></a></h3><ul><li><p><code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的，但性能较低。</p></li><li><p><code>HashMap</code> 允许存储 <code>null</code> 键和值，<code>Hashtable</code> 不允许。</p></li><li><p>Java 8 之后 <code>HashMap</code> 在链表长度大于 8 时会转换为红黑树，而 <code>Hashtable</code> 没有这种机制。</p></li></ul><h3 id="hashmap-的负载因子" tabindex="-1"><a class="header-anchor" href="#hashmap-的负载因子"><span>HashMap 的负载因子？</span></a></h3><p>负载因子决定了何时扩容，默认是 0.75。较低的负载因子减少碰撞，但会浪费空间，较高的负载因子减少空间占用，但可能增加哈希碰撞的概率。</p><h3 id="达到负载因子的阈值后-hashmap-具体扩容的倍数" tabindex="-1"><a class="header-anchor" href="#达到负载因子的阈值后-hashmap-具体扩容的倍数"><span>达到负载因子的阈值后，HashMap 具体扩容的倍数？</span></a></h3><p>当 <code>HashMap</code> 达到负载因子的阈值时，会进行扩容，容量一般是当前容量的两倍。扩容时，<code>HashMap</code> 会创建一个新数组，并将旧数组中的元素重新哈希到新数组中。</p><h3 id="从红黑树转回链表为什么阈值是-6" tabindex="-1"><a class="header-anchor" href="#从红黑树转回链表为什么阈值是-6"><span>从红黑树转回链表为什么阈值是 6？</span></a></h3><p>在 <code>HashMap</code> 中，链表长度超过 8 时会转为红黑树，当长度减少到 6 时会转回链表。这是为了平衡空间和时间的复杂度。红黑树的操作虽然更快（O (log n)），但维护成本和内存占用比链表高，因此当节点较少时，转回链表能提高效率。</p><h3 id="hashmap-时间复杂度" tabindex="-1"><a class="header-anchor" href="#hashmap-时间复杂度"><span>HashMap 时间复杂度？</span></a></h3><ol><li><p><strong>插入操作（put）</strong>：平均 O (1)，最坏 O (n)（当发生大量碰撞时）。</p></li><li><p><strong>查找操作（get）</strong>：平均 O (1)，最坏 O (n)，使用红黑树后最坏情况为 O (log n)。</p></li><li><p><strong>删除操作（remove）</strong>：平均 O (1)，最坏 O (n)，使用红黑树时为 O (log n)。</p></li><li><p><strong>遍历操作</strong>：O (n)。</p></li></ol><h3 id="为什么-hashmap-是线程不安全的-哪个操作可能导致它线程不安全-如果仍想用你该如何解决" tabindex="-1"><a class="header-anchor" href="#为什么-hashmap-是线程不安全的-哪个操作可能导致它线程不安全-如果仍想用你该如何解决"><span>为什么 HashMap 是线程不安全的，哪个操作可能导致它线程不安全，如果仍想用你该如何解决？</span></a></h3><p><code>HashMap</code> 是线程不安全的，尤其在多线程环境下插入和扩容操作时会出现数据不一致或死循环的风险。例如，多个线程同时对 <code>HashMap</code> 进行 <code>put</code> 操作时，可能会导致数据覆盖或丢失。此外，扩容过程中的 rehash 操作也可能引发问题。</p><p>要解决这个问题，可以使用以下方法：</p><ol><li><p><strong><code>Collections.synchronizedMap</code></strong>：将 <code>HashMap</code> 包装成线程安全的 <code>Map</code>。</p></li><li><p><strong><code>ConcurrentHashMap</code></strong>：更高效的线程安全 <code>Map</code> 实现，适合高并发场景。</p></li><li><p><strong>手动同步</strong>：通过 <code>synchronized</code> 关键字对共享的 <code>HashMap</code> 进行操作。</p></li></ol><h3 id="有哪些线程安全的-map" tabindex="-1"><a class="header-anchor" href="#有哪些线程安全的-map"><span>有哪些线程安全的 Map？</span></a></h3><ol><li><p><strong><code>ConcurrentHashMap</code></strong>：适用于高并发环境，采用分段锁机制。</p></li><li><p><strong><code>Collections.synchronizedMap</code></strong>：将非线程安全的 <code>Map</code> 包装成线程安全的。</p></li><li><p><strong><code>ConcurrentSkipListMap</code></strong>：线程安全的有序 <code>Map</code>，基于跳表结构。</p></li><li><p><strong><code>Hashtable</code></strong>：老旧的线程安全 <code>Map</code>，每个方法上都使用同步，性能较低。</p></li></ol><h3 id="concurrenthashmap-的-put-过程" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap-的-put-过程"><span>ConcurrentHashMap 的 put 过程？</span></a></h3><ol><li><p><strong>计算哈希值</strong>：对键进行哈希计算，得到哈希值。</p></li><li><p><strong>定位桶位置</strong>：根据哈希值找到桶（bucket）的索引。</p></li><li><p><strong>检查数组是否初始化</strong>：如果数组未初始化，执行线程安全的初始化操作。</p></li><li><p><strong>插入操作</strong>：</p><ul><li><p>如果桶为空，使用 CAS 操作插入新节点；</p></li><li><p>如果桶不为空，使用 <code>synchronized</code> 锁定该桶，处理链表或红黑树中的节点插入操作。</p></li></ul></li><li><p><strong>处理哈希碰撞</strong>：当冲突发生时，遍历链表或红黑树进行插入操作。链表长度超过阈值（默认 8）时转换为红黑树。</p></li><li><p><strong>结束操作</strong>：释放锁并更新状态（如元素数量）。</p></li></ol><p>通过 CAS、细粒度锁、链表转红黑树的机制，<code>ConcurrentHashMap</code> 高效地处理并发插入操作。</p><h3 id="concurrenthashmap-如何保证线程安全" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap-如何保证线程安全"><span>ConcurrentHashMap 如何保证线程安全？</span></a></h3><ol><li><p><strong>JDK 1.7 分段锁</strong>：使用 <code>Segment</code> 将哈希表分为多个部分，每个部分有独立锁，允许并发访问不同段的数据。</p></li><li><p><strong>JDK 1.8 无锁+细粒度锁</strong>：抛弃 <code>Segment</code>，采用 <code>Node + CAS + synchronized</code> 机制，锁只在必要时针对某个桶，减少锁竞争，提高并发度。</p></li><li><p><strong>CAS 操作</strong>：保证无锁下的原子性更新操作。</p></li><li><p><strong>读操作</strong>：大多数读操作为无锁，减少性能开销。</p></li></ol><p>JDK 1.8 中，<code>ConcurrentHashMap</code> 实现了更高效的并发控制，锁粒度更细，提高了读写性能。</p><h3 id="hashmap-为什么使用红黑树" tabindex="-1"><a class="header-anchor" href="#hashmap-为什么使用红黑树"><span>HashMap 为什么使用红黑树？</span></a></h3><ol><li><p><strong>自平衡特性</strong>：红黑树保证了最坏情况下操作的时间复杂度为 (O (\\log n))，通过着色和旋转来维持平衡。</p></li><li><p><strong>高效的插入和删除</strong>：红黑树的旋转操作相对较少，性能优于其他平衡树（如 AVL 树）。</p></li><li><p><strong>链表优化</strong>：链表长度超过阈值时转换为红黑树，大幅提升查找效率。</p></li></ol><p>红黑树在性能和复杂度上更适合解决 HashMap 中的高冲突情况。</p>',29);function c(r,i){return o(),s("div",null,[n,h("more"),l])}const g=e(t,[["render",c],["__file","浅谈HashMap.html.vue"]]),M=JSON.parse(`{"path":"/%E6%96%87%E7%AB%A0/%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/%E6%B5%85%E8%B0%88HashMap.html","title":"「浅谈HashMap」","lang":"zh-CN","frontmatter":{"title":"「浅谈HashMap」","author":"Jogs","date":"2024-10-11T00:00:00.000Z","category":["技术"],"tag":["Java"],"editLink":false,"description":"来自 gpt 的摘要： HashMap 是一种基于数组和链表（或红黑树）的数据结构，用于存储键值对。在插入元素时，通过键的 hashCode() 方法计算哈希值，并经过扰动函数确定元素在数组中的位置。Java 8 之前，HashMap 通过链表解决哈希碰撞问题，而在 Java 8 之后，当链表长度超过 8 时，链表会转换为红黑树，以提升效率。当 Has...","head":[["meta",{"property":"og:url","content":"https://jogs-abc.github.io/%E6%96%87%E7%AB%A0/%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/%E6%B5%85%E8%B0%88HashMap.html"}],["meta",{"property":"og:site_name","content":"Jogs' blog"}],["meta",{"property":"og:title","content":"「浅谈HashMap」"}],["meta",{"property":"og:description","content":"来自 gpt 的摘要： HashMap 是一种基于数组和链表（或红黑树）的数据结构，用于存储键值对。在插入元素时，通过键的 hashCode() 方法计算哈希值，并经过扰动函数确定元素在数组中的位置。Java 8 之前，HashMap 通过链表解决哈希碰撞问题，而在 Java 8 之后，当链表长度超过 8 时，链表会转换为红黑树，以提升效率。当 Has..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Jogs"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:published_time","content":"2024-10-11T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"「浅谈HashMap」\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-10-11T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Jogs\\"}]}"]]},"headers":[{"level":3,"title":"HashMap 底层原理？","slug":"hashmap-底层原理","link":"#hashmap-底层原理","children":[]},{"level":3,"title":"HashMap 和 HashSet 的区别？","slug":"hashmap-和-hashset-的区别","link":"#hashmap-和-hashset-的区别","children":[]},{"level":3,"title":"HashMap 和 Hashtable 的区别？","slug":"hashmap-和-hashtable-的区别","link":"#hashmap-和-hashtable-的区别","children":[]},{"level":3,"title":"HashMap 的负载因子？","slug":"hashmap-的负载因子","link":"#hashmap-的负载因子","children":[]},{"level":3,"title":"达到负载因子的阈值后，HashMap 具体扩容的倍数？","slug":"达到负载因子的阈值后-hashmap-具体扩容的倍数","link":"#达到负载因子的阈值后-hashmap-具体扩容的倍数","children":[]},{"level":3,"title":"从红黑树转回链表为什么阈值是 6？","slug":"从红黑树转回链表为什么阈值是-6","link":"#从红黑树转回链表为什么阈值是-6","children":[]},{"level":3,"title":"HashMap 时间复杂度？","slug":"hashmap-时间复杂度","link":"#hashmap-时间复杂度","children":[]},{"level":3,"title":"为什么 HashMap 是线程不安全的，哪个操作可能导致它线程不安全，如果仍想用你该如何解决？","slug":"为什么-hashmap-是线程不安全的-哪个操作可能导致它线程不安全-如果仍想用你该如何解决","link":"#为什么-hashmap-是线程不安全的-哪个操作可能导致它线程不安全-如果仍想用你该如何解决","children":[]},{"level":3,"title":"有哪些线程安全的 Map？","slug":"有哪些线程安全的-map","link":"#有哪些线程安全的-map","children":[]},{"level":3,"title":"ConcurrentHashMap 的 put 过程？","slug":"concurrenthashmap-的-put-过程","link":"#concurrenthashmap-的-put-过程","children":[]},{"level":3,"title":"ConcurrentHashMap 如何保证线程安全？","slug":"concurrenthashmap-如何保证线程安全","link":"#concurrenthashmap-如何保证线程安全","children":[]},{"level":3,"title":"HashMap 为什么使用红黑树？","slug":"hashmap-为什么使用红黑树","link":"#hashmap-为什么使用红黑树","children":[]}],"git":{},"readingTime":{"minutes":5.56,"words":1669},"filePathRelative":"文章/技术整理/浅谈HashMap.md","localizedDate":"2024年10月11日","excerpt":"<blockquote>\\n<p>来自 gpt 的摘要：\\nHashMap 是一种基于数组和链表（或红黑树）的数据结构，用于存储键值对。在插入元素时，通过键的 hashCode() 方法计算哈希值，并经过扰动函数确定元素在数组中的位置。Java 8 之前，HashMap 通过链表解决哈希碰撞问题，而在 Java 8 之后，当链表长度超过 8 时，链表会转换为红黑树，以提升效率。当 HashMap 的元素数量达到其容量的 75% 时，触发扩容，容量通常增加为原来的两倍。\\nHashMap 和 HashSet 的主要区别在于前者存储键值对，而后者仅存储对象。HashSet 的底层依赖于 HashMap，通过 HashMap 的键来存储对象。相比之下，HashMap 是非线程安全的，而 Hashtable 是线程安全的，但性能较低。此外，HashMap 允许 null 键和值，而 Hashtable 不允许。\\nHashMap 在多线程环境下可能不安全，尤其在插入和扩容操作时，可能导致数据不一致或死循环。要解决这个问题，可以使用 ConcurrentHashMap，它通过细粒度锁和 CAS（Compare-And-Swap）机制保证并发环境下的安全性。</p>\\n</blockquote>","autoDesc":true}`);export{g as comp,M as data};
