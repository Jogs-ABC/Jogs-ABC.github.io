import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as n,c as d,b as c,d as e,e as a,f as l,w as s,a as t,o as r}from"./app-BbCbJOw_.js";const h={},p=t('<h2 id="java-中的各类集合关系-能说一下吗" tabindex="-1"><a class="header-anchor" href="#java-中的各类集合关系-能说一下吗"><span>Java 中的各类集合关系，能说一下吗？</span></a></h2><h3 id="gpt" tabindex="-1"><a class="header-anchor" href="#gpt"><span>GPT：</span></a></h3><p>在 Java 中，集合框架（Collection Framework）提供了一组接口和类来处理一组对象（称为集合）。Java 集合框架的核心接口包括 <code>Collection</code>、<code>List</code>、<code>Set</code> 和 <code>Map</code>。下面是这些接口及其主要实现类的关系和区别：</p><h4 id="collection-接口" tabindex="-1"><a class="header-anchor" href="#collection-接口"><span>Collection 接口</span></a></h4><p><code>Collection</code> 是集合层次结构的根接口。它提供了基本的集合操作，如添加、删除和迭代元素。</p><h4 id="list-接口" tabindex="-1"><a class="header-anchor" href="#list-接口"><span>List 接口</span></a></h4><p><code>List</code> 是一个有序集合（也称为序列），它允许重复的元素。实现 <code>List</code> 接口的类包括：</p><ol><li><p><strong>ArrayList</strong></p><ul><li>基于动态数组实现。</li><li>允许快速的随机访问元素。</li><li>插入和删除操作在列表尾部的时间复杂度为 O (1)，在中间位置的时间复杂度为 O (n)。</li></ul></li><li><p><strong>LinkedList</strong></p><ul><li>基于双向链表实现。</li><li>允许快速插入和删除操作（时间复杂度为 O (1)）。</li><li>随机访问元素的时间复杂度为 O (n)。</li></ul></li><li><p><strong>Vector</strong></p><ul><li>类似于 <code>ArrayList</code>，但它是同步的（线程安全）。</li><li>因为同步，所以性能相对较差。</li></ul></li><li><p><strong>Stack</strong></p><ul><li>是 <code>Vector</code> 的子类，实现了栈的行为（LIFO：后进先出）。</li></ul></li></ol><h4 id="set-接口" tabindex="-1"><a class="header-anchor" href="#set-接口"><span>Set 接口</span></a></h4><p><code>Set</code> 是一个不允许重复元素的集合。实现 <code>Set</code> 接口的类包括：</p><ol><li><p><strong>HashSet</strong></p><ul><li>基于哈希表实现。</li><li>不保证集合的迭代顺序。</li><li>插入、删除、查找操作的时间复杂度为 O (1)。</li></ul></li><li><p><strong>LinkedHashSet</strong></p><ul><li>继承自 <code>HashSet</code>，并使用链表维护元素的插入顺序。</li><li>保证迭代时的顺序。</li></ul></li><li><p><strong>TreeSet</strong></p><ul><li>基于红黑树实现。</li><li>保证集合的自然顺序（或自定义的比较器顺序）。</li><li>插入、删除、查找操作的时间复杂度为 O (log n)。</li></ul></li></ol><h4 id="map-接口" tabindex="-1"><a class="header-anchor" href="#map-接口"><span>Map 接口</span></a></h4><p><code>Map</code> 是一个键值对的集合，键是唯一的。实现 <code>Map</code> 接口的类包括：</p><ol><li><p><strong>HashMap</strong></p><ul><li>基于哈希表实现。</li><li>不保证映射的顺序。</li><li>插入、删除、查找操作的时间复杂度为 O (1)。</li></ul></li><li><p><strong>LinkedHashMap</strong></p><ul><li>继承自 <code>HashMap</code>，并使用链表维护键值对的插入顺序。</li><li>保证迭代时的顺序。</li></ul></li><li><p><strong>TreeMap</strong></p><ul><li>基于红黑树实现。</li><li>保证键值对的自然顺序（或自定义的比较器顺序）。</li><li>插入、删除、查找操作的时间复杂度为 O (log n)。</li></ul></li><li><p><strong>Hashtable</strong></p><ul><li>类似于 <code>HashMap</code>，但它是同步的（线程安全）。</li><li>因为同步，所以性能相对较差。</li></ul></li></ol><h4 id="queue-接口" tabindex="-1"><a class="header-anchor" href="#queue-接口"><span>Queue 接口</span></a></h4><p><code>Queue</code> 是一个按特定顺序来处理元素的集合。实现 <code>Queue</code> 接口的类包括：</p><ol><li><p><strong>PriorityQueue</strong></p><ul><li>基于优先级堆实现。</li><li>保证元素按照优先级顺序出队。</li></ul></li><li><p><strong>ArrayDeque</strong></p><ul><li>基于动态数组实现的双端队列。</li><li>支持在两端快速插入和删除元素。</li></ul></li></ol><h4 id="deque-接口" tabindex="-1"><a class="header-anchor" href="#deque-接口"><span>Deque 接口</span></a></h4><p><code>Deque</code> 继承自 <code>Queue</code>，是一种双端队列，支持在两端进行插入和删除操作。实现 <code>Deque</code> 接口的类包括 <code>ArrayDeque</code> 和 <code>LinkedList</code>。</p><p>通过这些接口和实现类，Java 提供了一个灵活且强大的集合框架，支持不同类型的数据结构和操作需求。</p><h3 id="javaguide" tabindex="-1"><a class="header-anchor" href="#javaguide"><span>javaguide ：</span></a></h3><h4 id="java-集合概览" tabindex="-1"><a class="header-anchor" href="#java-集合概览"><span>Java 集合概览</span></a></h4><p>Java 集合，也叫作容器，主要是由两大接口派生而来：一个是 <code>Collection</code> 接口，主要用于存放单一元素；另一个是 <code>Map</code> 接口，主要用于存放键值对。对于 <code>Collection</code> 接口，下面又有三个主要的子接口：<code>List</code>、<code>Set</code> 、 <code>Queue</code>。</p><p>Java 集合框架如下图所示：</p><figure><img src="https://oss.javaguide.cn/github/javaguide/java/collection/java-collection-hierarchy.png" alt="Java 集合框架概览" tabindex="0" loading="lazy"><figcaption>Java 集合框架概览</figcaption></figure><p>注：图中只列举了主要的继承派生关系，并没有列举所有关系。比方省略了 <code>AbstractList</code>, <code>NavigableSet</code> 等抽象类以及其他的一些辅助类，如想深入了解，可自行查看源码。</p><h4 id="说说-list-set-queue-map-四者的区别" tabindex="-1"><a class="header-anchor" href="#说说-list-set-queue-map-四者的区别"><span>说说 List, Set, Queue, Map 四者的区别？</span></a></h4><ul><li><code>List</code> (对付顺序的好帮手): 存储的元素是有序的、可重复的。</li><li><code>Set</code> (注重独一无二的性质): 存储的元素不可重复的。</li><li><code>Queue</code> (实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li><li><code>Map</code> (用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y=f (x)，&quot;x&quot; 代表 key，&quot;y&quot; 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li></ul><h2 id="你在实际开发中分别在哪些应用场景用过呢" tabindex="-1"><a class="header-anchor" href="#你在实际开发中分别在哪些应用场景用过呢"><span>你在实际开发中分别在哪些应用场景用过呢？</span></a></h2><h3 id="gpt-1" tabindex="-1"><a class="header-anchor" href="#gpt-1"><span>GPT：</span></a></h3><p>在面试中回答实际开发中使用不同集合的场景时，可以根据自己的项目经验，结合集合的特性来描述。这不仅展示了你对集合框架的理解，还表明你能够在实际应用中灵活使用它们。以下是一些常见的应用场景，可以参考这些示例并结合你的实际经验来回答：</p><h4 id="arraylist" tabindex="-1"><a class="header-anchor" href="#arraylist"><span>ArrayList</span></a></h4><p><strong>应用场景</strong>：当需要频繁读取元素，而插入和删除操作较少时。 <strong>实际例子</strong>：在一个电商网站中，用于存储和展示商品列表。用户浏览商品时，系统需要快速展示商品信息，而不需要频繁更新列表。</p><h4 id="linkedlist" tabindex="-1"><a class="header-anchor" href="#linkedlist"><span>LinkedList</span></a></h4><p><strong>应用场景</strong>：当需要频繁插入和删除操作，而随机访问较少时。 <strong>实际例子</strong>：实现一个任务队列，用于管理后台处理任务。任务可以随时添加到队列中或从队列中删除。</p><h4 id="hashset" tabindex="-1"><a class="header-anchor" href="#hashset"><span>HashSet</span></a></h4><p><strong>应用场景</strong>：需要快速查找元素，并且不允许重复元素。 <strong>实际例子</strong>：在一个社交网络应用中，用于存储用户的好友列表。确保好友列表中没有重复用户，并能快速检查一个用户是否已经是好友。</p><h4 id="linkedhashset" tabindex="-1"><a class="header-anchor" href="#linkedhashset"><span>LinkedHashSet</span></a></h4><p><strong>应用场景</strong>：需要维护元素的插入顺序，同时要求快速查找和不允许重复。 <strong>实际例子</strong>：在一个购物车系统中，用于存储用户添加到购物车中的商品，按用户添加的顺序展示商品。</p><h4 id="treeset" tabindex="-1"><a class="header-anchor" href="#treeset"><span>TreeSet</span></a></h4><p><strong>应用场景</strong>：需要对元素进行排序，并且不允许重复。 <strong>实际例子</strong>：在一个竞赛系统中，用于存储参赛者的分数，自动按照分数排序，以便实时显示排行榜。</p><h4 id="hashmap" tabindex="-1"><a class="header-anchor" href="#hashmap"><span>HashMap</span></a></h4><p><strong>应用场景</strong>：需要快速查找键值对，且不要求有序。 <strong>实际例子</strong>：在一个用户管理系统中，用于存储用户信息，其中用户 ID 作为键，用户详细信息作为值，便于快速检索用户数据。</p><h4 id="linkedhashmap" tabindex="-1"><a class="header-anchor" href="#linkedhashmap"><span>LinkedHashMap</span></a></h4><p><strong>应用场景</strong>：需要维护键值对的插入顺序，并且要求快速查找。 <strong>实际例子</strong>：在一个缓存系统中，用于存储最近访问的网页，按访问顺序存储，以便在缓存满时移除最早访问的页面。</p><h4 id="treemap" tabindex="-1"><a class="header-anchor" href="#treemap"><span>TreeMap</span></a></h4><p><strong>应用场景</strong>：需要对键进行排序，并且要求快速查找。 <strong>实际例子</strong>：在一个日志系统中，用于存储日志记录，其中时间戳作为键，日志内容作为值，自动按时间排序，方便查询和分析日志。</p><h4 id="priorityqueue" tabindex="-1"><a class="header-anchor" href="#priorityqueue"><span>PriorityQueue</span></a></h4><p><strong>应用场景</strong>：需要按照优先级处理元素。 <strong>实际例子</strong>：在一个任务调度系统中，用于管理需要按优先级执行的任务，确保高优先级任务先执行。</p><h4 id="arraydeque" tabindex="-1"><a class="header-anchor" href="#arraydeque"><span>ArrayDeque</span></a></h4><p><strong>应用场景</strong>：需要双端队列，支持在两端快速插入和删除。 <strong>实际例子</strong>：在一个浏览器中，用于实现前进和后退功能。用户可以快速在历史记录中前进和后退。</p><h4 id="stack" tabindex="-1"><a class="header-anchor" href="#stack"><span>Stack</span></a></h4><p><strong>应用场景</strong>：需要后进先出的栈结构。 <strong>实际例子</strong>：在一个表达式求值程序中，用于存储运算符和操作数，按后进先出顺序计算表达式的值。</p><h4 id="hashtable" tabindex="-1"><a class="header-anchor" href="#hashtable"><span>Hashtable</span></a></h4><p><strong>应用场景</strong>：需要线程安全的键值对存储。 <strong>实际例子</strong>：在一个多线程应用中，用于存储共享的配置信息，确保在并发访问时的数据一致性。</p><p><strong>回答示例</strong>：</p><p>“在我们的电商项目中，我使用 <code>ArrayList</code> 来存储和展示商品列表，因为我们需要快速随机访问商品信息。在实现一个后台任务队列时，我选择了 <code>LinkedList</code>，因为任务的插入和删除操作比较频繁。为了存储用户的好友列表，我使用了 <code>HashSet</code>，确保列表中没有重复用户，并能快速查找好友。在我们的缓存系统中，我使用了 <code>LinkedHashMap</code> 来维护最近访问的网页，按访问顺序存储以便在缓存满时移除最早访问的页面。”</p><h3 id="javaguide-1" tabindex="-1"><a class="header-anchor" href="#javaguide-1"><span>javaguide：</span></a></h3><p>先来看一下 <code>Collection</code> 接口下面的集合。</p><h5 id="list" tabindex="-1"><a class="header-anchor" href="#list"><span>List</span></a></h5>',60),u=e("code",null,"ArrayList",-1),g=e("code",null,"Object[]",-1),A=e("li",null,[e("code",null,"Vector"),a("："),e("code",null,"Object[]"),a(" 数组。")],-1),E=e("code",null,"LinkedList",-1),_=t('<h5 id="set" tabindex="-1"><a class="header-anchor" href="#set"><span>Set</span></a></h5><ul><li><code>HashSet</code> (无序，唯一): 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素。</li><li><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。</li><li><code>TreeSet</code> (有序，唯一): 红黑树 (自平衡的排序二叉树)。</li></ul><h5 id="queue" tabindex="-1"><a class="header-anchor" href="#queue"><span>Queue</span></a></h5>',3),f=e("code",null,"PriorityQueue",-1),B=e("code",null,"Object[]",-1),v=e("code",null,"DelayQueue",-1),k=e("code",null,"PriorityQueue",-1),L=e("li",null,[e("code",null,"ArrayDeque"),a(": 可扩容动态双向数组。")],-1),b=e("p",null,[a("再来看看 "),e("code",null,"Map"),a(" 接口下面的集合。")],-1),m=e("h5",{id:"map",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#map"},[e("span",null,"Map")])],-1),x=e("code",null,"HashMap",-1),y=e("code",null,"HashMap",-1),H=e("code",null,"HashMap",-1),M=e("code",null,"LinkedHashMap",-1),C=e("code",null,"LinkedHashMap",-1),S=e("code",null,"HashMap",-1),j=e("code",null,"LinkedHashMap",-1),q=e("li",null,[e("code",null,"Hashtable"),a("：数组+链表组成的，数组是 "),e("code",null,"Hashtable"),a(" 的主体，链表则是主要为了解决哈希冲突而存在的。")],-1),F=e("li",null,[e("code",null,"TreeMap"),a("：红黑树（自平衡的排序二叉树）。")],-1),J=t('<h4 id="如何选用集合" tabindex="-1"><a class="header-anchor" href="#如何选用集合"><span>如何选用集合 ?</span></a></h4><p>我们主要根据集合的特点来选择合适的集合。比如：</p><ul><li>我们需要根据键值获取到元素值时就选用 <code>Map</code> 接口下的集合，需要排序时选择 <code>TreeMap</code>, 不需要排序时就选择 <code>HashMap</code>, 需要保证线程安全就选用 <code>ConcurrentHashMap</code>。</li><li>我们只需要存放元素值时，就选择实现 <code>Collection</code> 接口的集合，需要保证元素唯一时选择实现 <code>Set</code> 接口的集合比如 <code>TreeSet</code> 或 <code>HashSet</code>，不需要就选择实现 <code>List</code> 接口的比如 <code>ArrayList</code> 或 <code>LinkedList</code>，然后再根据实现这些接口的集合的特点来选用。</li></ul><h4 id="为什么要使用集合" tabindex="-1"><a class="header-anchor" href="#为什么要使用集合"><span>为什么要使用集合？</span></a></h4><p>当我们需要存储一组类型相同的数据时，数组是最常用且最基本的容器之一。但是，使用数组存储对象存在一些不足之处，因为在实际开发中，存储的数据类型多种多样且数量不确定。这时，Java 集合就派上用场了。与数组相比，Java 集合提供了更灵活、更有效的方法来存储多个数据对象。Java 集合框架中的各种集合类和接口可以存储不同类型和数量的对象，同时还具有多样化的操作方式。相较于数组，Java 集合的优势在于它们的大小可变、支持泛型、具有内建算法等。总的来说，Java 集合提高了数据的存储和处理灵活性，可以更好地适应现代软件开发中多样化的数据需求，并支持高质量的代码编写。</p>',5);function D(Q,T){const o=n("RouteLink");return r(),d("div",null,[c("more"),p,e("ul",null,[e("li",null,[u,a("："),g,a(" 数组。详细可以查看："),l(o,{to:"/%E6%96%87%E7%AB%A0/%EF%BC%88%E5%8A%A0%E5%AF%86%EF%BC%89%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/arraylist-source-code.html"},{default:s(()=>[a("ArrayList 源码分析")]),_:1}),a("。")]),A,e("li",null,[E,a("：双向链表 (JDK 1.6 之前为循环链表，JDK 1.7 取消了循环)。详细可以查看："),l(o,{to:"/%E6%96%87%E7%AB%A0/%EF%BC%88%E5%8A%A0%E5%AF%86%EF%BC%89%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/linkedlist-source-code.html"},{default:s(()=>[a("LinkedList 源码分析")]),_:1}),a("。")])]),_,e("ul",null,[e("li",null,[f,a(": "),B,a(" 数组来实现小顶堆。详细可以查看："),l(o,{to:"/%E6%96%87%E7%AB%A0/%EF%BC%88%E5%8A%A0%E5%AF%86%EF%BC%89%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/priorityqueue-source-code.html"},{default:s(()=>[a("PriorityQueue 源码分析")]),_:1}),a("。")]),e("li",null,[v,a(": "),k,a("。详细可以查看："),l(o,{to:"/%E6%96%87%E7%AB%A0/%EF%BC%88%E5%8A%A0%E5%AF%86%EF%BC%89%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/delayqueue-source-code.html"},{default:s(()=>[a("DelayQueue 源码分析")]),_:1}),a("。")]),L]),b,m,e("ul",null,[e("li",null,[x,a("：JDK 1.8 之前 "),y,a(" 由数组+链表组成的，数组是 "),H,a(" 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK 1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。详细可以查看："),l(o,{to:"/%E6%96%87%E7%AB%A0/%EF%BC%88%E5%8A%A0%E5%AF%86%EF%BC%89%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/hashmap-source-code.html"},{default:s(()=>[a("HashMap 源码分析")]),_:1}),a("。")]),e("li",null,[M,a("："),C,a(" 继承自 "),S,a("，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，"),j,a(" 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看："),l(o,{to:"/%E6%96%87%E7%AB%A0/%EF%BC%88%E5%8A%A0%E5%AF%86%EF%BC%89%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/linkedhashmap-source-code.html"},{default:s(()=>[a("LinkedHashMap 源码分析")]),_:1})]),q,F]),J])}const N=i(h,[["render",D],["__file","集合八股.html.vue"]]),V=JSON.parse('{"path":"/%E6%96%87%E7%AB%A0/%EF%BC%88%E5%8A%A0%E5%AF%86%EF%BC%89%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/%E9%9B%86%E5%90%88%E5%85%AB%E8%82%A1.html","title":"集合八股（仅作个人在线笔记和材料整理，非原创，暂不外流。）","lang":"zh-CN","frontmatter":{"title":"集合八股（仅作个人在线笔记和材料整理，非原创，暂不外流。）","icon":"lock","author":"Jogs","date":"2024-07-06T00:00:00.000Z","category":["八股","加密"],"tag":["集合"],"editLink":false,"feed":false,"seo":false,"head":[]},"headers":[{"level":2,"title":"Java 中的各类集合关系，能说一下吗？","slug":"java-中的各类集合关系-能说一下吗","link":"#java-中的各类集合关系-能说一下吗","children":[{"level":3,"title":"GPT：","slug":"gpt","link":"#gpt","children":[]},{"level":3,"title":"javaguide ：","slug":"javaguide","link":"#javaguide","children":[]}]},{"level":2,"title":"你在实际开发中分别在哪些应用场景用过呢？","slug":"你在实际开发中分别在哪些应用场景用过呢","link":"#你在实际开发中分别在哪些应用场景用过呢","children":[{"level":3,"title":"GPT：","slug":"gpt-1","link":"#gpt-1","children":[]},{"level":3,"title":"javaguide：","slug":"javaguide-1","link":"#javaguide-1","children":[]}]}],"git":{},"readingTime":{"minutes":10.42,"words":3127},"filePathRelative":"文章/（加密）个人笔记/集合八股.md","localizedDate":"2024年7月6日"}');export{N as comp,V as data};
