import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,b as a,a as e,o as n}from"./app-BQvkpm6l.js";const l="/assets/images/JDK%E6%BA%90%E7%A0%81%E4%B9%8BObject%E7%B1%BB.png",t="/assets/images/JDK%E6%BA%90%E7%A0%81%E4%B9%8BObject%E7%B1%BB-2.png",h={},p=e('<h2 id="写在前面" tabindex="-1"><a class="header-anchor" href="#写在前面"><span>写在前面</span></a></h2><ul><li><p>本文依据 JDK8 源码进行编写</p></li><li><p>关于 native 修饰的方法不进行内部剖析</p></li><li><p>只对核心方法进行剖析</p></li></ul><blockquote><p>什么是 native 方法？官方给的说明是&quot;A native method is a Java method whose implementation is provided by non-java code.&quot; 通俗的说，native 表示该方法的实现 java 本身并没有完成，而是有 c/c++来完成，放在.dll 动态库文件中。</p></blockquote><h2 id="object-类结构" tabindex="-1"><a class="header-anchor" href="#object-类结构"><span>Object 类结构</span></a></h2><figure><img src="'+l+`" alt="Object类结构" tabindex="0" loading="lazy"><figcaption>Object类结构</figcaption></figure><h2 id="类构造器" tabindex="-1"><a class="header-anchor" href="#类构造器"><span>类构造器</span></a></h2><p>Object 类没有显式声明构造器，因此 Object 类使用的是默认的无参构造器。</p><h2 id="equals-方法" tabindex="-1"><a class="header-anchor" href="#equals-方法"><span>equals 方法</span></a></h2><h3 id="源码" tabindex="-1"><a class="header-anchor" href="#源码"><span>源码：</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> boolean</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> equals</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> obj) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">     return</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> ==</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> obj)</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从源码中可以得知，在 Object 类中，<strong>== 运算符和 equals 方法是等价的</strong>，都是比较两个对象的引用是否相等，从另一方面来讲，如果两个对象的引用相等，那么这两个对象一定是相等的。</p><p>对于我们自定义的一个对象，<strong>如果不重写 equals 方法，那么在比较对象的时候就是调用 Object 类的 equals 方法，也就是用 == 运算符比较两个对象</strong>。</p><h3 id="思考" tabindex="-1"><a class="header-anchor" href="#思考"><span>思考：</span></a></h3><h4 id="equals-方法和-运算符的区别-我们应该如何重写-equals-方法" tabindex="-1"><a class="header-anchor" href="#equals-方法和-运算符的区别-我们应该如何重写-equals-方法"><span>equals 方法和 == 运算符的区别？我们应该如何重写 equals 方法？</span></a></h4><p>一般从面试题中我们可以得知：== 运算符可以用来比较基本数据类型，也可以用来比较引用数据类型，比较的重点在两个对象的内存地址是否相等；equals 方法主要用来比较引用数据类型，一般我们都会重写，重写后的 equals 方法主要是比较两个对象的值是否相等。因此，两者的侧重点是不同的。</p><p>但我们在源码中得知，Object 类中的 equals 方法本质上是调用 == 运算符，我们想要实现对值的比较必须要对 equals 方法进行重写，我们可以参考一下 String 类是如何重写 equals 方法：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">	public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> boolean</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> equals</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> anObject) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">        // 如果内存地址相等，那必须equal</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> ==</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> anObject) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">            return</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">        // 如果对象是String类型 </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> (anObject </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">instanceof</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> String) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">            String</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> anotherString </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> (String)anObject</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">            // 获取调用方的字符串长度赋值给n</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">            int</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> value</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">            // 判断长度相等</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> (n </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> anotherString</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">                char</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> v1[] </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> value</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">                char</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> v2[] </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> anotherString</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">                int</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">                // 那我们就逐个字符的比较</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">                while</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> (n</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">--</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> !=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">                    // 从前往后，任意一个字符不匹配，直接返回false</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">                    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> (v1[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!=</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> v2[i])</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">                        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">                    i</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">                }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">                // 全部匹配结束，返回true</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">                return</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>String 是引用类型，比较时不能比较引用是否相等，重点是字符串的内容是否相等。所以 String 类定义两个对象相等的标准是<strong>字符串内容都相同</strong>。</p><p><strong>在Java规范中，对 equals 方法的使用必须遵循以下几个原则：</strong></p><p>① 自反性：对于任何非空引用值 x，x.equals(x) 都应返回 true。</p><p>② 对称性：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才应返回 true。</p><p>③ 传递性：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true，并且 y.equals(z) 返回 true，那么 x.equals(z) 应返回 true。</p><p>④ 一致性：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改</p><p>⑤ 对于任何非空引用值 x，x.equals(null) 都应返回 false。</p><h4 id="为何重写-equals-方法就得重写-hashcode-方法" tabindex="-1"><a class="header-anchor" href="#为何重写-equals-方法就得重写-hashcode-方法"><span>为何重写 equals 方法就得重写 hashCode 方法？</span></a></h4><p>在 equals 源码注释上官方说明了，在重写 equals 方法时也要重写 hashCode 方法，目的是为了保证相同对象有相同的 hash 值。</p><figure><img src="`+t+`" alt="equals源码注释" tabindex="0" loading="lazy"><figcaption>equals源码注释</figcaption></figure><p>为什么相同对象一定要有相同的 hash 值？</p><p>关于这个问题，我们要从它们的应用场景来说。在 Java 中有很多集合类用到了 hashCode 方法，如 HashMap，HashSet 等，它们的底层结构是一个哈希表，在存储数据的 key 值时，要先获取到对应的 hash 值，针对这个值进行一定的扰动，然后与数组的长度做一个运算，最终计算出对应的下标，根据这个下标把 key 和 value 封装成一个对象存到底层的数组。在整个过程中，我们需要用到 hashCode。</p><p>假设我们需要再次存储一个一样的对象，理论上来说，key 值相同我们需要对 value 值进行覆盖，那么在第二次添加时我们怎么知道这两个值是否相等？假如我们直接调用重写后的 equals 方法进行比较，由于重写后 equals 方法的内部逻辑可能非常复杂，这样效率是很低的。因此我们可以先利用 hash 值做对比，hash 值不相等时直接返回，在 hash 值相等的情况下再通过 equals 方法进行确认。</p><p>基于这种机制，假如我们重写了 equals 方法却没有重写 hashCode 方法，就会发生 equals 比较是相等的但 hash 值却不同的情况，这样数据就会混乱。</p><h2 id="tostring-方法" tabindex="-1"><a class="header-anchor" href="#tostring-方法"><span>toString 方法</span></a></h2><p>源码：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> getClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">getName</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> &quot;@&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> Integer</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">toHexString</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">hashCode</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">());</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p><code>getClass().getName()</code> 是返回对象的全类名（包含包名）, <code>Integer.toHexString(hashCode())</code> 是以16进制无符号整数形式返回此哈希码的字符串表示形式。</p></li><li><p>打印某个对象时，默认是调用 toString 方法，比如 <code>System.out.println(person)</code>,等价于 <code>System.out.println(person.toString())</code>。</p></li></ul><h2 id="finalize-方法" tabindex="-1"><a class="header-anchor" href="#finalize-方法"><span>finalize 方法</span></a></h2><p>源码：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">protected</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> finalize</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">() throws Throwable { }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><p>当 GC 确定不再有对该对象的引用时，GC 会调用对象的 <code>finalize()</code> 方法来清除回收。</p></li><li><p>Java VM 会确保一个对象的 <code>finalize()</code> 方法只被调用一次，而且程序中不能直接调用 <code>finalize()</code> 方法。</p></li><li><p><code>finalize()</code> 方法通常也不可预测，而且很危险，一般情况下，不必要覆盖 <code>finalize()</code> 方法。</p></li></ul><h2 id="registernatives-方法" tabindex="-1"><a class="header-anchor" href="#registernatives-方法"><span>registerNatives 方法</span></a></h2><p>源码：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> native</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> registerNatives</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这是一个本地方法，我们要知道一个类定义了本地方法后，想要调用操作系统的实现，必须还要装载本地库。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">        registerNatives</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>静态代码块就是一个类在初始化过程中必定会执行的内容，所以在类加载的时候是会执行该方法的，通过该方法来注册本地方法。</p>`,45);function k(r,d){return n(),s("div",null,[a("more"),p])}const o=i(h,[["render",k],["__file","JDK源码之Object类.html.vue"]]),u=JSON.parse(`{"path":"/%E6%96%87%E7%AB%A0/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JDK%E6%BA%90%E7%A0%81/JDK%E6%BA%90%E7%A0%81%E4%B9%8BObject%E7%B1%BB.html","title":"「JDK源码之Object类」","lang":"zh-CN","frontmatter":{"title":"「JDK源码之Object类」","author":"Jogs","date":"2024-10-25T00:00:00.000Z","category":["源码"],"tag":["JDK"],"editLink":false,"description":"写在前面 本文依据 JDK8 源码进行编写 关于 native 修饰的方法不进行内部剖析 只对核心方法进行剖析 什么是 native 方法？官方给的说明是\\"A native method is a Java method whose implementation is provided by non-java code.\\" 通俗的说，native 表示...","head":[["meta",{"property":"og:url","content":"https://jogs-abc.github.io/%E6%96%87%E7%AB%A0/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JDK%E6%BA%90%E7%A0%81/JDK%E6%BA%90%E7%A0%81%E4%B9%8BObject%E7%B1%BB.html"}],["meta",{"property":"og:site_name","content":"Jogs' blog"}],["meta",{"property":"og:title","content":"「JDK源码之Object类」"}],["meta",{"property":"og:description","content":"写在前面 本文依据 JDK8 源码进行编写 关于 native 修饰的方法不进行内部剖析 只对核心方法进行剖析 什么是 native 方法？官方给的说明是\\"A native method is a Java method whose implementation is provided by non-java code.\\" 通俗的说，native 表示..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://jogs-abc.github.io/assets/images/JDK源码之Object类.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Jogs"}],["meta",{"property":"article:tag","content":"JDK"}],["meta",{"property":"article:published_time","content":"2024-10-25T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"「JDK源码之Object类」\\",\\"image\\":[\\"https://jogs-abc.github.io/assets/images/JDK源码之Object类.png\\",\\"https://jogs-abc.github.io/assets/images/JDK源码之Object类-2.png\\"],\\"datePublished\\":\\"2024-10-25T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Jogs\\"}]}"]]},"headers":[{"level":2,"title":"写在前面","slug":"写在前面","link":"#写在前面","children":[]},{"level":2,"title":"Object 类结构","slug":"object-类结构","link":"#object-类结构","children":[]},{"level":2,"title":"类构造器","slug":"类构造器","link":"#类构造器","children":[]},{"level":2,"title":"equals 方法","slug":"equals-方法","link":"#equals-方法","children":[{"level":3,"title":"源码：","slug":"源码","link":"#源码","children":[]},{"level":3,"title":"思考：","slug":"思考","link":"#思考","children":[]}]},{"level":2,"title":"toString 方法","slug":"tostring-方法","link":"#tostring-方法","children":[]},{"level":2,"title":"finalize 方法","slug":"finalize-方法","link":"#finalize-方法","children":[]},{"level":2,"title":"registerNatives 方法","slug":"registernatives-方法","link":"#registernatives-方法","children":[]}],"git":{},"readingTime":{"minutes":5.36,"words":1609},"filePathRelative":"文章/源码分析/JDK源码/JDK源码之Object类.md","localizedDate":"2024年10月25日","excerpt":"<!--more-->\\n<h2>写在前面</h2>\\n<ul>\\n<li>\\n<p>本文依据 JDK8 源码进行编写</p>\\n</li>\\n<li>\\n<p>关于 native 修饰的方法不进行内部剖析</p>\\n</li>\\n<li>\\n<p>只对核心方法进行剖析</p>\\n</li>\\n</ul>\\n<blockquote>\\n<p>什么是 native 方法？官方给的说明是\\"A native method is a Java method whose implementation is provided by non-java code.\\" 通俗的说，native 表示该方法的实现 java 本身并没有完成，而是有 c/c++来完成，放在.dll 动态库文件中。</p>\\n</blockquote>","autoDesc":true}`);export{o as comp,u as data};
